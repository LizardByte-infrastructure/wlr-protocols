<?xml version="1.0" encoding="UTF-8"?>
<protocol name="wlr_export_dmabuf_unstable_v1">

  <copyright>
    Copyright Â© 2018 Rostislav Pehlivanov

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice (including the next
    paragraph) shall be included in all copies or substantial portions of the
    Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
  </copyright>

  <interface name="zwlr_export_dmabuf_manager_v1" version="1">
    <description summary="manages available buffers for capture">
      Clients who bind to this interface will receive events advertising a list
      of dmabuf sources available for export. This list may change over time, as
      new outputs and surfaces become available or are removed on the
      compositor.

      There is no guarantee that the compositor will send to the client all
      surfaces and outputs that it knows of. The compositor may ask the user
      which sources they wish to make available to the client, and the list of
      authorized sources may change at any time.
    </description>

    <event name="new_surface">
      <description summary="a new surface is available for capture">
    This event is sent when a new wl_surface is available for dmabuf export.

    The source_id can be passed to the capture request to initiate a capture and
    is guaranteed to be unique among all source_ids emitted on this
    zwlr_export_dmabuf_manager_v1, including those from events other than
    new_surface.

    If the new surface is a toplevel, the name is non-null and will be set to a
    user-friendly window title (for example, via xdg_toplevel::set_title) and
    the parent argument will not be meaningful.

    If the surface is the child of a toplevel (such as an xdg_popup), the name
    will be null and the parent argument set to the ID of a previous
    new_surface event. The parent ID may also be set to the source ID of an
    output, for example, if the output is using a hardware cursor.

    If a child surface is reparented, the source_removed event is sent and
    new_surface raised with the new relationship indicated.
      </description>
      <arg name="source_id" type="uint"
         summary="a unique dmabuf source identifier"/>
      <arg name="name" type="string" allow-null="true"
        summary="user friendly surface name"/>
      <arg name="parent" type="uint"
        summary="source_id of the parent surface"/>
    </event>

    <event name="new_output">
      <description summary="a new output is available for capture">
    This event is sent when a new wl_output is available for dmabuf export.

    The source_id can be passed to the capture request to initiate a capture and
    is guaranteed to be unique among all source_ids emitted on this
    zwlr_export_dmabuf_manager_v1, including those from events other than
    new_output.

    If the client binds to the same wl_output more than once, and that output is
    available for capture, this event is sent once for each resource.
      </description>
      <arg name="source_id" type="uint"
         summary="a unique dmabuf source identifier"/>
      <arg name="output" type="object" interface="wl_output"
        summary="the wl_output being offered"/>
    </event>

    <event name="source_removed">
      <description summary="indicates a source is no longer available">
    This event is sent when a source previously announced becomes unavailable.
    The client may still create a frame resource for this source, but it will
    not receive any frames from it (instead, the cancel event will be immediately
    sent).
      </description>
      <arg name="source_id" type="uint"
        summary="the source_id of the source which has been removed"/>
    </event>

    <request name="capture">
      <description summary="create a frame resource for a source">
    Creates a frame resource for the given source.

    See the documentation of zwlr_export_dmabuf_frame_v1 for more details about
    the interface and its usage.
      </description>
      <arg name="frame" type="new_id"
           interface="zwlr_export_dmabuf_frame_v1"/>
      <arg name="source_id" type="uint"
           summary="the source_id to receive frames for"/>
    </request>

    <!-- TODO: Define this protocol error -->
    <request name="destroy" type="destructor">
      <description summary="destroy the manager">
    Destroys this zwlr_export_dmabuf_manager_v1 object.

    Destroying a bound zwlr_export_dmabuf_manager_v1 object while there are
    still zwlr_export_dmabuf_frame_v1 objects alive is illegal and will result
    in a protocol error.
      </description>
    </request>
  </interface>

  <interface name="zwlr_export_dmabuf_frame_v1" version="1">
    <description summary="exports dmabuf frames for readout">
  This interface sends the client events that describe new frames available from
  a source obtained via zwlr_export_dmabuf_manager_v1.

  This interface exposes underlying details of VASurfaceAttribExternalBuffers,
  part of the Linux DRM interface. In many respects, this interface is the
  inverse of zwp_linux_buffer_params_v1. Unlike zwp_linux_buffer_params_v1, this
  also includes some additional information which, in the case of
  zwp_linux_buffer_params_v1, is normally configured through e.g. wl_surface.

  The compositor will send events detailing the size, transform, pixel format,
  file descriptors, and so on, which can be used to read the next frame. When
  the frame is ready, the "ready" event is sent and includes details about the
  presentation time of that frame. When the client is done reading the frame,
  they must send the "finish" request.

  All frames are read-only and may not be written into or altered.
    </description>

    <enum name="flags">
      <entry name="transient" value="0x1"
        summary="a short-lived frame the client should copy and process later"/>
    </enum>

    <event name="frame">
      <description summary="sends details of the next frame">
    The frame event is sent to configure various details about the next frame.
    This event is always sent before the first ready event, but will not be
    re-sent if the details do not change between frames.

    For details on the scale factor argument, see wl_surface::set_buffer_scale
    and wl_output::scale.
      </description>
      <arg name="width" type="uint"
           summary="width in pixels of the next frame"/>
      <arg name="height" type="uint"
           summary="height in pixels of the next frame"/>
      <arg name="scale" type="uint"
           summary="scale factor of the next frame"/>
      <arg name="transform" type="uint"
           summary="see wl_output.transform"/>
      <arg name="format" type="uint" summary="DRM_FORMAT code"/>
      <arg name="buffer_flags" type="uint"
           summary="see zwp_linux_buffer_params_v1:flags"/>
      <arg name="flags" type="uint" enum="flags"
           summary="see enum flags"/>
      <arg name="num_objects" type="uint"
           summary="indicates how many objects (FDs) the frame has (max 4)"/>
      <arg name="num_layers" type="uint"
           summary="indicates how many layers the frame has (max 4)"/>
    </event>

    <event name="plane">
      <description summary="adds a plane to the next frame">
    Adds a new plane to the next frame, providing format information and a file
    descriptor it may be read from.

    The compositor must use consecutive plane indices from zero to the number of
    planes used by the drm_fourcc format code. All planes required by the format
    must be given exactly once, but can be given in any order. Each plane index
    can be set only once.

    Single-planar formats only require one dmabuf, however multi-planar formats
    may require more than one dmabuf. For all formats, data_source is sent once
    per plane (even if the underlying dmabuf fd is identical).

    The 64-bit unsigned value combined from modifier_hi and modifier_lo is the
    dmabuf layout modifier. DRM AddFB2 ioctl calls this the fb modifier, which
    is defined in drm_mode.h of Linux UAPI. This is an opaque token. Drivers
    use this token to express tiling, compression, etc. driver-specific
    modifications to the base format defined by the DRM fourcc code.

    This event is always sent before the first ready event, but will not be
    re-sent if the details do not change between frames.
      </description>
      <arg name="index" type="uint"
           summary="index of the current object"/>
      <arg name="fd" type="fd"
           summary="fd of the current object"/>
      <arg name="offset" type="uint" summary="offset in bytes"/>
      <arg name="stride" type="uint" summary="stride in bytes"/>
      <arg name="modifier_hi" type="uint"
           summary="drm format modifier, high"/>
      <arg name="modifier_lo" type="uint"
           summary="drm format modifier, low"/>
    </event>

    <event name="position">
      <description summary="gives the position of child surfaces">
    For frame resources created from surfaces that are children of another
    source, this event is sent to indicate the position of the child surface in
    surface-local coordinates relative to its parent.

    This event is always sent before the first ready event, but will not be
    re-sent if the details do not change between frames. This event is never
    sent for sources which do not have parents.
      </description>
      <arg name="x" type="int" summary="x coordinate in the parent surface"/>
      <arg name="y" type="int" summary="y coordinate in the parent surface"/>
    </event>

    <event name="ready">
      <description summary="indicates frame is available for reading">
    The ready event is sent when a frame is presented and is available for
    reading.

    The timestamp is expressed as tv_sec_hi, tv_sec_lo, tv_nsec triples, each
    component being an unsigned 32-bit value. Whole seconds are in tv_sec which
    is a 64-bit value combined from tv_sec_hi and tv_sec_lo, and the additional
    fractional part in tv_nsec as nanoseconds. Hence, for valid timestamps
    tv_nsec must be in [0, 999999999].

    Timestamps are accurate relative to each other, but have an undefined epoch.
      </description>
      <arg name="tv_sec_hi" type="uint"
        summary="high 32 bits of the seconds part of the timestamp"/>
      <arg name="tv_sec_lo" type="uint"
        summary="low 32 bits of the seconds part of the timestamp"/>
      <arg name="tv_nsec" type="uint"
        summary="nanoseconds part of the timestamp"/>
    </event>

    <enum name="cancel_reason">
      <entry name="invalid_source" value="0"
        summary="the frame source is or has become invalid"/>
      <entry name="invalid_frame" value="1"
        summary="this frame is no longer valid"/>
    </enum>

    <event name="cancel">
      <description summary="indicates the frame is no longer valid">
    The compositor will send this event to cancel the current frame.

    The reason is set to invalid_frame when only the current frame is invalid.
    This would normally only happen if a client has attached a buffer (and thus
    the compositor passes along its information) but for some reason the frame
    was not rendered.

    The reason is set to invalid_source if the underlying source has become
    invalid. In this case, no frames will be sent to this resource after the
    cancel event and the client should destroy the resource.
      </description>
      <arg name="reason" type="uint" enum="cancel_reason"
        summary="indicates the reason this frame was cancelled"/>
    </event>

    <!-- TODO: Add this protocol error -->
    <request name="finish">
      <description summary="the client has finished reading">
    The client should send this request when it finishes reading the frame. It
    is a protocol error to send finish before the ready event, or to send it
    twice for a single frame.
      </description>
    </request>

    <request name="destroy" type="destructor">
      <description summary="releases the frame resource">
    Informs the server that the client will no longer be using this protocol
    object.
      </description>
    </request>
  </interface>

</protocol>
